/**
 * Copyright 2017 Juan Carlos Orozco Arena
 * Apache License Version 2.0
 */

/**
 * @fileoverview Block element construction functions
 * @author JC-Orozco (Juan Carlos Orozco)
 */
'use strict';

/**
 * Namespace for BlockConstructors
 */
goog.provide('BlockConstructors');

/**
 * @typedef {{root: Element, current: Element}} ElementPointers
 */

/**
 * Creates a factory_base Element
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param {string} connections Define block connections. Options: NONE, LEFT,
 *     UP, DOWN, BOTH
 * @param {string} name Block name
 * @param {boolean} inline Block layout inline or not
 * @param INPUTS
 * @param TOOLTIP
 * @param HELPURL
 * @param COLOUR
 */
BlockConstructors.factoryBase = function(data, connections, name, INLINE, INPUTS, TOOLTIP, HELPURL, COLOUR) {
  var block1 = FactoryUtils.newNode('block', {type: 'factory_base'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('mutation', {connections: connections}));
  block1.append(FactoryUtils.newNode('field', {name: 'NAME'}, name));
  block1.append(FactoryUtils.newNode('field', {name: 'INLINE'}, INLINE));
  block1.append(FactoryUtils.newNode('field', {name: 'CONNECTIONS'}, connections));
  block1.append(data.dst.current = FactoryUtils.newNode('statement', {name: 'INPUTS'}));
  INPUTS(data);
  data.dst.current = block1;
  block1.append(data.dst.current = FactoryUtils.newNode('value', {name: 'TOOLTIP'}));
  TOOLTIP(data);
  data.dst.current = block1;
  block1.append(data.dst.current = FactoryUtils.newNode('value', {name: 'HELPURL'}));
  HELPURL(data);
  data.dst.current = block1;
  block1.append(data.dst.current = FactoryUtils.newNode('value', {name: 'COLOUR'}));
  COLOUR(data);
  data.dst.current = block1;
};

/**
 * Creates a input_dummy Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param ALIGN
 * @param FIELDS
 */
BlockConstructors.inputDummy = function(data, ALIGN, FIELDS) {
  var block1 = FactoryUtils.newNode('block', {type: 'input_dummy'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'ALIGN'}, ALIGN));
  block1.append(data.dst.current = FactoryUtils.newNode('statement', {name: 'FIELDS'}));
  FIELDS(data);
  data.dst.current = block1;
};

/**
 * Creates a input_statement Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param INPUTNAME
 * @param ALIGN
 * @param FIELDS
 * @param TYPE
 */
BlockConstructors.inputStatement = function(data, INPUTNAME, ALIGN, FIELDS, TYPE) {
  var block1 = FactoryUtils.newNode('block', {type: 'input_statement'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'INPUTNAME'}, INPUTNAME));
  block1.append(FactoryUtils.newNode('field', {name: 'ALIGN'}, ALIGN));
  block1.append(data.dst.current = FactoryUtils.newNode('statement', {name: 'FIELDS'}));
  FIELDS(data);
  data.dst.current = block1;
  block1.append(data.dst.current = FactoryUtils.newNode('value', {name: 'TYPE'}));
  TYPE(data);
  data.dst.current = block1;
};

/**
 * Creates a input_value Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param INPUTNAME
 * @param ALIGN
 * @param FIELDS
 * @param TYPE
 */
BlockConstructors.inputValue = function(data, INPUTNAME, ALIGN, FIELDS, TYPE) {
  var block1 = FactoryUtils.newNode('block', {type: 'input_value'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'INPUTNAME'}, INPUTNAME));
  block1.append(FactoryUtils.newNode('field', {name: 'ALIGN'}, ALIGN));
  block1.append(data.dst.current = FactoryUtils.newNode('statement', {name: 'FIELDS'}));
  FIELDS(data);
  data.dst.current = block1;
  block1.append(data.dst.current = FactoryUtils.newNode('value', {name: 'TYPE'}));
  TYPE(data);
  data.dst.current = block1;
};

/**
 * Creates a field_static Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param TEXT
 */
BlockConstructors.fieldStatic = function(data, TEXT) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_static'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'TEXT'}, TEXT));
};

/**
 * Creates a field_input Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param TEXT
 * @param FIELDNAME
 */
BlockConstructors.fieldInput = function(data, TEXT, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_input'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'TEXT'}, TEXT));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
};

/**
 * Creates a field_number Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param VALUE
 * @param FIELDNAME
 * @param MIN
 * @param MAX
 * @param PRECISION
 */
BlockConstructors.fieldNumber = function(data, VALUE, FIELDNAME, MIN, MAX, PRECISION) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_number'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'VALUE'}, VALUE));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
  block1.append(FactoryUtils.newNode('field', {name: 'MIN'}, MIN));
  block1.append(FactoryUtils.newNode('field', {name: 'MAX'}, MAX));
  block1.append(FactoryUtils.newNode('field', {name: 'PRECISION'}, PRECISION));
};

/**
 * Creates a field_angle Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param ANGLE
 * @param FIELDNAME
 */
BlockConstructors.fieldAngle = function(data, ANGLE, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_angle'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'ANGLE'}, ANGLE));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
};

/**
 * Creates a dropdown field Element
 * @param {!data} data Data structure that stores source and destination nodes with their corresponding current nodes.
 * @param {Array<string>} options List of options for the dropdown field.
 * @param {string} FIELDNAME Name of the field.
 */
BlockConstructors.fieldDropdown = function(data, options, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_dropdown'});
  var OPTIONS = '[';
  
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  var mutation = FactoryUtils.newNode('mutation'); 
  block1.append(mutation);
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
  for (let i=0; i<options.length; i++) {
    let option = options[i];
    if (typeof option[0] === "string") {
      OPTIONS+='&quot;text&quot;,'
      block1.append(FactoryUtils.newNode('field', {name: 'USER'+i}, option[0]));
    } else {
      OPTIONS+='&quot;image&quot;,';
      block1.append(FactoryUtils.newNode('field', {name: 'SRC'+i}, option[0].src));
      block1.append(FactoryUtils.newNode('field', {name: 'WIDTH'+i}, option[0].width));
      block1.append(FactoryUtils.newNode('field', {name: 'HEIGHT'+i}, option[0].height));
      block1.append(FactoryUtils.newNode('field', {name: 'ALT'+i}, option[0].alt));
    }
    block1.append(FactoryUtils.newNode('field', {name: 'CPU'+i}, option[1]));
  }
  OPTIONS = OPTIONS.slice(0,-1); // Drop last comma 
  OPTIONS += ']';
  mutation.setAttribute('options', OPTIONS);
};

/**
 * Creates a field_checkbox Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param CHECKED
 * @param FIELDNAME
 */
BlockConstructors.fieldCheckbox = function(data, CHECKED, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_checkbox'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'CHECKED'}, CHECKED));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
};

/**
 * Creates a field_colour Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param COLOUR
 * @param FIELDNAME
 */
BlockConstructors.fieldColour = function(data, COLOUR, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_colour'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'COLOUR'}, COLOUR));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
};

/**
 * Creates a field_variable Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param TEXT
 * @param FIELDNAME
 */
BlockConstructors.fieldVariable = function(data, TEXT, FIELDNAME) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_variable'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'TEXT'}, TEXT));
  block1.append(FactoryUtils.newNode('field', {name: 'FIELDNAME'}, FIELDNAME));
};

/**
 * Creates a field_image Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param SRC
 * @param WIDTH
 * @param HEIGHT
 * @param ALT
 */
BlockConstructors.fieldImage = function(data, SRC, WIDTH, HEIGHT, ALT) {
  var block1 = FactoryUtils.newNode('block', {type: 'field_image'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'SRC'}, SRC));
  block1.append(FactoryUtils.newNode('field', {name: 'WIDTH'}, WIDTH));
  block1.append(FactoryUtils.newNode('field', {name: 'HEIGHT'}, HEIGHT));
  block1.append(FactoryUtils.newNode('field', {name: 'ALT'}, ALT));
};

/**
 * Creates a group type Element
 * @param {!data} data Data structure that stores source and destination nodes with their corresponding current nodes.
 * @param {Array<string>} types List of types of this type group.
 * @return {number} Returns 0.
 */
BlockConstructors.typeGroup = function(data, types) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_group'});

  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('mutation', {types:types.length}));
  for (let i=0; i<types.length; i++) {
    let type = types[i];
    let value = FactoryUtils.newNode('value', {name:'TYPE'+i});
    block1.append(value);
    data.dst.current = value;
    FactoryUtils.parseType(data, type);
  }
  data.dst.current = block1;
};

/**
 * Creates a type_null shadow Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeNullShadow = function(data) {
  var block1 = FactoryUtils.newNode('shadow', {type: 'type_null'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_null Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeNull = function(data) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_null'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_boolean Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeBoolean = function(data) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_boolean'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_number Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeNumber = function(data) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_number'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_string Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeString = function(data) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_string'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_list Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 */
BlockConstructors.typeList = function(data) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_list'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
};

/**
 * Creates a type_other Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param TYPE
 */
BlockConstructors.typeOther = function(data, TYPE) {
  var block1 = FactoryUtils.newNode('block', {type: 'type_other'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'TYPE'}, TYPE));
};

/**
 * Creates a colour_hue Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param colour
 * @param HUE
 */
BlockConstructors.colourHue = function(data, colour, HUE) {
  var block1 = FactoryUtils.newNode('block', {type: 'colour_hue'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('mutation', {colour:colour.toString()}));
  block1.append(FactoryUtils.newNode('field', {name: 'HUE'}, HUE.toString()));
};

/**
 * Creates a text Element
 * This is an automaticaly generated function
 * The first parameter is data plus an autogenerated parameter list
 * @param {{src: ElementPointers, dst: ElementPointers}} data Data structure
 *     that stores source and destination nodes with their corresponding current
 *     nodes.
 * @param TEXT
 */
BlockConstructors.text = function(data, TEXT) {
  var block1 = FactoryUtils.newNode('block', {type: 'text'});
  if (!FactoryUtils.firstStatement(data.dst.current)) {
    let nextBlock = FactoryUtils.newNode('next');
    data.dst.current.append(nextBlock);
    data.dst.current = nextBlock;
  }
  data.dst.current.append(block1);
  data.dst.current = block1;
  block1.append(FactoryUtils.newNode('field', {name: 'TEXT'}, TEXT));
};
